// Proton2025 Theme - Temperature Sensor RPC Module
// Reads thermal sensors from /sys/class/thermal and /sys/class/hwmon

'use strict';

import { readfile, lsdir } from 'fs';

// Storage for peak temperatures (persists while rpcd is running)
let peakTemps = {};

// Read file content safely, return null on error
function readFileContent(path) {
	let content = readfile(path);
	return content ? trim(content) : null;
}

// Simple glob for thermal/hwmon directories
function findDirs(basePath, prefix) {
	let entries = lsdir(basePath);
	if (!entries) return [];
	
	let result = [];
	for (let name in entries) {
		if (index(name, prefix) == 0) {
			push(result, basePath + '/' + name);
		}
	}
	return result;
}

// Get all temperature sensors
function getSensors() {
	let sensors = [];
	
	// === 1. Read thermal_zone sensors ===
	let thermalZones = findDirs('/sys/class/thermal', 'thermal_zone');
	
	for (let zonePath in thermalZones) {
		let temp = readFileContent(zonePath + '/temp');
		if (temp == null) continue;
		
		let tempValue = +temp;
		if (tempValue != tempValue) continue; // NaN check
		
		let type = readFileContent(zonePath + '/type') || 'thermal';
		
		// Update peak temperature
		let key = zonePath;
		if (peakTemps[key] == null || tempValue > peakTemps[key]) {
			peakTemps[key] = tempValue;
		}
		
		push(sensors, {
			name: type,
			temp: tempValue,
			peak: peakTemps[key],
			path: zonePath,
			source: 'thermal_zone'
		});
	}
	
	// === 2. Read hwmon sensors ===
	let hwmonDirs = findDirs('/sys/class/hwmon', 'hwmon');
	
	for (let hwmonPath in hwmonDirs) {
		let deviceName = readFileContent(hwmonPath + '/name') || 'hwmon';
		
		// Find all temp*_input files
		let files = lsdir(hwmonPath);
		if (!files) continue;
		
		for (let file in files) {
			// Check if file matches temp*_input pattern
			if (index(file, 'temp') != 0 || index(file, '_input') < 0)
				continue;
			
			let tempPath = hwmonPath + '/' + file;
			let temp = readFileContent(tempPath);
			if (temp == null) continue;
			
			let tempValue = +temp;
			if (tempValue != tempValue) continue; // NaN check
			
			// Extract index from temp1_input -> 1
			let idx = substr(file, 4, index(file, '_input') - 4);
			
			// Try to read label
			let labelPath = hwmonPath + '/temp' + idx + '_label';
			let label = readFileContent(labelPath);
			
			let sensorName = label || deviceName;
			
			// Check for duplicates with thermal_zone
			let isDuplicate = false;
			for (let s in sensors) {
				if (s.source == 'thermal_zone') {
					let diff = s.temp - tempValue;
					if (diff < 0) diff = -diff;
					if (diff < 2000) {
						isDuplicate = true;
						break;
					}
				}
			}
			
			if (!isDuplicate) {
				// Update peak temperature
				let key = tempPath;
				if (peakTemps[key] == null || tempValue > peakTemps[key]) {
					peakTemps[key] = tempValue;
				}
				
				push(sensors, {
					name: sensorName,
					temp: tempValue,
					peak: peakTemps[key],
					path: tempPath,
					source: 'hwmon'
				});
			}
		}
	}
	
	return { sensors: sensors };
}

// Reset all peak temperatures
function resetPeaks() {
	peakTemps = {};
	return { success: true };
}

// RPC method definitions
const methods = {
	getSensors: {
		call: function() {
			return getSensors();
		}
	},
	resetPeaks: {
		call: function() {
			return resetPeaks();
		}
	}
};

return { 'luci.proton-temp': methods };
